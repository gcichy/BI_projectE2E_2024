#!/usr/bin/env python3
from __future__ import annotations

import argparse
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Iterator, Literal, Optional

import pandas as pd
from docx import Document
from lxml import etree


# --- Namespaces (WordprocessingML + DrawingML + VML + WordprocessingShape) ---
W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main"
A_NS = "http://schemas.openxmlformats.org/drawingml/2006/main"
R_NS = "http://schemas.openxmlformats.org/officeDocument/2006/relationships"
WP_NS = "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing"
PIC_NS = "http://schemas.openxmlformats.org/drawingml/2006/picture"
WPS_NS = "http://schemas.microsoft.com/office/word/2010/wordprocessingShape"
V_NS = "urn:schemas-microsoft-com:vml"

NS = {
    "w": W_NS,
    "a": A_NS,
    "r": R_NS,
    "wp": WP_NS,
    "pic": PIC_NS,
    "wps": WPS_NS,
    "v": V_NS,
}


def qn(ns_uri: str, local: str) -> str:
    return f"{{{ns_uri}}}{local}"


@dataclass
class ImageItem:
    filename: str
    content_type: str
    bytes: bytes


ItemKind = Literal["paragraph", "textbox", "table", "image"]


@dataclass
class ContentItem:
    idx: int
    kind: ItemKind
    # exactly one of these will be populated depending on kind
    text: Optional[str] = None
    table_i: Optional[int] = None
    image_i: Optional[int] = None
    meta: dict[str, Any] | None = None


@dataclass
class ParsedDocx:
    items: list[ContentItem]
    tables: list[pd.DataFrame]
    images: list[ImageItem]


def iter_body_blocks(doc: Document) -> Iterator[etree._Element]:
    """Yield body-level XML blocks in order (<w:p>, <w:tbl>, etc.)."""
    body = doc.element.body
    yield from body.iterchildren()


def table_to_dataframe(table) -> pd.DataFrame:
    rows: list[list[str]] = []
    max_cols = 0
    for row in table.rows:
        vals = [cell.text for cell in row.cells]
        max_cols = max(max_cols, len(vals))
        rows.append(vals)
    rows = [r + [""] * (max_cols - len(r)) for r in rows]
    return pd.DataFrame(rows)


def extract_images_from_paragraph(paragraph, doc: Document) -> list[ImageItem]:
    """
    Extract inline images referenced in a paragraph via <a:blip r:embed="...">.
    """
    out: list[ImageItem] = []
    p_elm = paragraph._p

    blips = p_elm.xpath(".//a:blip[@r:embed]", namespaces=NS)
    for blip in blips:
        r_id = blip.get(qn(R_NS, "embed"))
        if not r_id:
            continue

        rel = doc.part.rels.get(r_id)
        if rel is None:
            continue

        part = rel.target_part
        blob = part.blob
        content_type = getattr(part, "content_type", "application/octet-stream")
        filename = getattr(part, "filename", None) or r_id

        out.append(ImageItem(filename=Path(filename).name, content_type=content_type, bytes=blob))

    return out


def extract_textboxes_from_paragraph(paragraph) -> list[str]:
    """
    Extract text from text boxes embedded in a paragraph.

    Handles two common forms:
    - DrawingML WordprocessingShape: .//wps:txbx//w:txbxContent
    - Legacy VML: .//v:textbox//w:txbxContent
    """
    p_elm = paragraph._p

    # Find all txbxContent nodes in document order (both wps and vml variants)
    txbx_contents = p_elm.xpath(
        ".//w:txbxContent | .//wps:txbx//w:txbxContent | .//v:textbox//w:txbxContent",
        namespaces=NS,
    )

    texts: list[str] = []
    for txbx in txbx_contents:
        # Collect paragraph texts inside the textbox in order
        ps = txbx.xpath(".//w:p", namespaces=NS)
        parts: list[str] = []
        for p in ps:
            # Join all w:t in that textbox paragraph; include w:tab and w:br roughly
            t_nodes = p.xpath(".//w:t", namespaces=NS)
            line = "".join((t.text or "") for t in t_nodes).strip()
            if line:
                parts.append(line)
        if parts:
            # Represent textbox content as multi-line text
            texts.append("\n".join(parts))

    return texts


def parse_docx(path: str | Path, include_empty_paragraphs: bool = False) -> ParsedDocx:
    doc = Document(str(path))

    items: list[ContentItem] = []
    tables: list[pd.DataFrame] = []
    images: list[ImageItem] = []

    # python-docx stores paragraphs and tables separately; we “consume” them in body XML order.
    para_iter = iter(doc.paragraphs)
    table_iter = iter(doc.tables)

    idx_counter = 0

    for block in iter_body_blocks(doc):
        local = etree.QName(block.tag).localname

        if local == "p":
            p = next(para_iter)
            para_text = p.text or ""

            # Add paragraph item
            if include_empty_paragraphs or para_text.strip():
                idx_counter += 1
                items.append(ContentItem(idx=idx_counter, kind="paragraph", text=para_text))

            # Add textbox items (ordered after the host paragraph, in XML order)
            for tb_text in extract_textboxes_from_paragraph(p):
                idx_counter += 1
                items.append(ContentItem(idx=idx_counter, kind="textbox", text=tb_text))

            # Add image items in this paragraph (ordered after textbox items, still “within” this paragraph)
            for img in extract_images_from_paragraph(p, doc):
                images.append(img)
                idx_counter += 1
                items.append(
                    ContentItem(
                        idx=idx_counter,
                        kind="image",
                        image_i=len(images) - 1,
                        meta={"filename": img.filename, "content_type": img.content_type},
                    )
                )

        elif local == "tbl":
            t = next(table_iter)
            df = table_to_dataframe(t)
            tables.append(df)

            idx_counter += 1
            items.append(ContentItem(idx=idx_counter, kind="table", table_i=len(tables) - 1))

        else:
            # e.g., sectPr; ignored
            continue

    return ParsedDocx(items=items, tables=tables, images=images)


def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("path", type=str, help="Path to .docx file")
    ap.add_argument("--export-images", type=str, default=None, help="Directory to save extracted images")
    ap.add_argument("--export-tables", type=str, default=None, help="Directory to save extracted tables as CSV")
    ap.add_argument("--include-empty-paragraphs", action="store_true")
    args = ap.parse_args()

    parsed = parse_docx(args.path, include_empty_paragraphs=args.include_empty_paragraphs)

    print(f"Items:  {len(parsed.items)}")
    print(f"Tables: {len(parsed.tables)}")
    print(f"Images: {len(parsed.images)}")

    if args.export_images:
        out_dir = Path(args.export_images)
        out_dir.mkdir(parents=True, exist_ok=True)
        for i, img in enumerate(parsed.images, start=1):
            # avoid collisions
            name = img.filename or f"image_{i}"
            p = out_dir / name
            if p.exists():
                p = out_dir / f"{p.stem}_{i}{p.suffix}"
            p.write_bytes(img.bytes)
        print(f"Saved images to: {out_dir}")

    if args.export_tables:
        out_dir = Path(args.export_tables)
        out_dir.mkdir(parents=True, exist_ok=True)
        for i, df in enumerate(parsed.tables, start=1):
            df.to_csv(out_dir / f"table_{i}.csv", index=False)
        print(f"Saved tables to: {out_dir}")

    # Example: print ordered outline
    for it in parsed.items[:30]:
        if it.kind in ("paragraph", "textbox"):
            preview = (it.text or "").replace("\n", "\\n")
            if len(preview) > 80:
                preview = preview[:77] + "..."
            print(f"{it.idx:04d} {it.kind}: {preview}")
        elif it.kind == "table":
            df = parsed.tables[it.table_i]  # type: ignore[index]
            print(f"{it.idx:04d} table: shape={df.shape}")
        elif it.kind == "image":
            meta = it.meta or {}
            print(f"{it.idx:04d} image: {meta.get('filename')} ({meta.get('content_type')})")


if __name__ == "__main__":
    main()
